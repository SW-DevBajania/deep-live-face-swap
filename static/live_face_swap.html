<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Audio-Video Streaming</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #f4f4f4;
            font-family: Arial, sans-serif;
        }
        video, canvas {
            width: 45%;
            height: 300px;
            margin: 10px;
            border: 2px solid #333;
        }
        .video-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .controls {
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            margin: 0 10px;
            font-size: 16px;
            cursor: pointer;
        }
        .upload-container {
            text-align: center;
            padding: 15px;
            background: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        #uploadStatus {
            font-size: 14px;
            margin-top: 10px;
        }
        
        input[type="file"] {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 300px;
        }
    </style>
</head>
<body>
    <h2>Live Audio-Video Streaming</h2>
    <div class="upload-container" style="margin-bottom: 20px;">
        <h3>Upload Source Face Image</h3>
        <input type="file" id="sourceImage" accept="image/*" style="margin-bottom: 10px;">
        <button onclick="uploadSourceImage()">Upload Face Image</button>
        <div id="uploadStatus" style="margin-top: 5px; color: green;"></div>
    </div>
    <div class="video-container">
        <video id="originalStream" autoplay muted></video>
        <canvas id="processedStream" autoplay></canvas>
        <audio id="processedAudio" autoplay></audio>
    </div>
    <div class="controls">
        <button onclick="startStream()">Start</button>
        <button onclick="stopStream()">Stop</button>
    </div>

    <script>
        let originalStreamElement = document.getElementById('originalStream');
        let processedCanvas = document.getElementById('processedStream');
        let processedCtx = processedCanvas.getContext('2d');
        let audioElement = document.getElementById('processedAudio');
        let mediaStream = null;
        let socket = null;
        let audioContext;
        let audioWorkletNode;
        let mediaSource;
        let sourceBuffer;
        const MAX_BUFFER_SIZE = 2; // Maximum buffer size in seconds
        let frameQueue = [];
        let audioQueue = [];  // Queue for audio data
        let lastFrameTime = 0;
        const frameInterval = 100;  // Throttle video rendering to every 100ms
        let isDisplaying = false;

        // Update the audio initialization
        async function initAudioProcessing() {
            try {
                const audioContext = new AudioContext({
                    sampleRate: 48000,
                    latencyHint: 'interactive'
                });

                // Load audio worklet
                await audioContext.audioWorklet.addModule('/static/audio-processor.js');
                
                const stream = new MediaStream([mediaStream.getAudioTracks()[0]]);
                const source = audioContext.createMediaStreamSource(stream);
                
                const workletNode = new AudioWorkletNode(audioContext, 'audio-processor');
                source.connect(workletNode);
                workletNode.connect(audioContext.destination);

                return audioContext;
            } catch (error) {
                console.error('Audio processing initialization failed:', error);
                return null;
            }
        }

        // Update startStream function
        async function startStream() {
            const uploadStatus = document.getElementById('uploadStatus');
            if (!uploadStatus.textContent.includes('successful')) {
                alert('Please upload a source face image first');
                return;
            }

            try {
                // Stop any existing streams
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                }

                // Capture media with specific constraints
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 1280,
                        height: 720,
                        frameRate: { ideal: 30, max: 30 },
                        facingMode: 'user'
                    },
                    audio: false  // Disable audio for now to focus on video
                });

                // Set up video preview
                originalStreamElement.srcObject = mediaStream;
                await originalStreamElement.play();

                // Create WebSocket connection
                if (socket) {
                    socket.close();
                }

                socket = new WebSocket('wss://54.242.212.173:8000/stream');
                let isConnected = false;

                socket.onopen = () => {
                    console.log('WebSocket connected');
                    isConnected = true;
                    startCapture();
                };

                socket.onclose = async (event) => {
                    console.log('WebSocket closed:', event.reason);
                    isConnected = false;
                    
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        startStream();
                    }
                };

                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };

                // Handle incoming messages
                socket.onmessage = async (event) => {
                    if (event.data instanceof Blob) {
                        const buffer = await event.data.arrayBuffer();
                        const header = new Uint8Array(buffer.slice(0, 6));
                        const payload = buffer.slice(6);

                        if (new TextDecoder().decode(header) === "VIDEO:") {
                            const blob = new Blob([payload], { type: 'image/jpeg' });
                            frameQueue.push(blob);
                            if (!isDisplaying) {
                                isDisplaying = true;
                                requestAnimationFrame(displayProcessedFrames);
                            }
                        }
                    }
                };

                function startCapture() {
                    const videoTrack = mediaStream.getVideoTracks()[0];
                    if (!videoTrack || videoTrack.readyState !== 'live') {
                        console.error('Video track is not ready');
                        return;
                    }

                    const imageCapture = new ImageCapture(videoTrack);
                    let isCapturing = true;

                    async function captureFrame() {
                        if (!isConnected || !isCapturing) return;

                        try {
                            const frame = await imageCapture.grabFrame();
                            const canvas = document.createElement('canvas');
                            canvas.width = frame.width;
                            canvas.height = frame.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(frame, 0, 0);

                            if (socket && socket.readyState === WebSocket.OPEN) {
                                canvas.toBlob((blob) => {
                                    socket.send(new Blob([new TextEncoder().encode("VIDEO:"), blob]));
                                }, 'image/jpeg', 0.9);
                            }
                        } catch (error) {
                            console.error('Frame capture error:', error);
                            isCapturing = false;
                            return;
                        }

                        requestAnimationFrame(captureFrame);
                    }

                    captureFrame();
                }

            } catch (error) {
                console.error('Error starting stream:', error);
            }
        }

        function stopStream() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => {
                    track.stop();
                });
                mediaStream = null;
            }

            if (socket) {
                socket.close();
                socket = null;
            }

            isDisplaying = false;
            frameQueue = [];
            
            // Clear the video elements
            originalStreamElement.srcObject = null;
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
        }
        
        const displayProcessedFrames = async () => {
            if (!isDisplaying) return;

            if (frameQueue.length > 0) {
                const frameBlob = frameQueue.shift();
                try {
                    const img = await createImageBitmap(frameBlob);
                    processedCanvas.width = img.width;
                    processedCanvas.height = img.height;
                    processedCtx.drawImage(img, 0, 0);
                    img.close();
                } catch (error) {
                    console.error('Error displaying frame:', error);
                }
            }

            if (frameQueue.length > 30) {
                frameQueue.length = 30; // Limit queue size
            }

            if (socket && socket.readyState === WebSocket.OPEN) {
                requestAnimationFrame(displayProcessedFrames);
            } else {
                isDisplaying = false;
            }
        };

        // Error handling for the audio element
        audioElement.addEventListener('error', () => {
            console.warn('Audio playback error. Clearing SourceBuffer.');
            if (sourceBuffer && sourceBuffer.buffered.length > 0) {
                sourceBuffer.remove(0, sourceBuffer.buffered.end(0));
            }
        });

        // Update the stream URL generation button
        const generateStreamBtn = document.createElement('button');
        generateStreamBtn.textContent = 'Generate Stream URL';
        generateStreamBtn.onclick = async () => {
            try {
                const response = await fetch('/generate-stream-url');
                const data = await response.json();
                
                const urlDisplay = document.createElement('div');
                urlDisplay.innerHTML = `
                    <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px;">
                        <h3>Streaming URLs:</h3>
                        <p><strong>RTMP URL</strong> (Standard):<br>
                        <input type="text" value="${data.rtmp_url}" readonly style="width: 100%; padding: 5px;"></p>
                        
                        <p><strong>SRT URL</strong> (Lower Latency):<br>
                        <input type="text" value="${data.srt_url}" readonly style="width: 100%; padding: 5px;"></p>
                        
                        <h4>Instructions:</h4>
                        <ol>
                            ${data.instructions.vlc.map(instruction => `<li>${instruction}</li>`).join('')}
                        </ol>
                    </div>
                `;
                document.body.appendChild(urlDisplay);
            } catch (error) {
                console.error('Error generating stream URL:', error);
                alert('Error generating stream URL. Please try again.');
            }
        };
        document.body.appendChild(generateStreamBtn);

        async function uploadSourceImage() {
            const fileInput = document.getElementById('sourceImage');
            const uploadStatus = document.getElementById('uploadStatus');
            
            if (!fileInput.files || !fileInput.files[0]) {
                uploadStatus.style.color = 'red';
                uploadStatus.textContent = 'Please select an image first';
                return;
            }

            const formData = new FormData();
            formData.append('file', fileInput.files[0]);

            try {
                uploadStatus.style.color = 'blue';
                uploadStatus.textContent = 'Uploading...';
                
                const response = await fetch('/upload_source_image', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (response.ok) {
                    uploadStatus.style.color = 'green';
                    uploadStatus.textContent = 'Upload successful! You can now start streaming.';
                } else {
                    throw new Error(result.detail || 'Upload failed');
                }
            } catch (error) {
                uploadStatus.style.color = 'red';
                uploadStatus.textContent = `Error: ${error.message}`;
            }
        }

    </script>
</body>
</html>
